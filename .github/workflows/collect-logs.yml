name: Collect all workflow logs
on:
  workflow_run:
    workflows: ["CI", "test", "docs"]
    types: [completed]
  workflow_dispatch:
    inputs:
      sha:
        description: SHA to collect (optional)
        required: false
        type: string
      targets:
        description: JSON array of workflow names (optional)
        required: false
        type: string
permissions:
  actions: read
  contents: write
concurrency:
  group: collect-logs-${{ github.event.workflow_run.head_sha || inputs.sha || github.sha }}
  cancel-in-progress: true
jobs:
  collect:
    runs-on: ubuntu-latest
    if: ${{ !(github.event_name == 'workflow_run' && github.event.workflow_run.event == 'pull_request' && github.event.workflow_run.head_repository.full_name != github.repository) }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      OWNER_REPO: ${{ github.repository }}
      HEAD_SHA: ${{ github.event.workflow_run.head_sha || inputs.sha || github.sha }}
      HEAD_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
      TARGETS: '["CI","test","docs"]'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.HEAD_BRANCH }}
      - name: Resolve targets
        id: targets
        run: |
          python3 - <<'PY'
          import os

          it = os.environ.get("INPUT_TARGETS", "").strip()
          envt = os.environ.get("TARGETS", "[]").strip()
          value = it if it else envt
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"list={value}\n")
          PY
      - name: Wait for all workflows to finish for this SHA (only on workflow_run)
        if: ${{ github.event_name == 'workflow_run' }}
        run: |
          python3 - <<'PY'
          import os, json, urllib.request, urllib.parse, time
          repo = os.environ["OWNER_REPO"]
          sha = os.environ["HEAD_SHA"]
          targets = json.loads(os.environ["TARGETS"])
          headers = {
              "Authorization": f"Bearer {os.environ['GH_TOKEN']}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "gha-log-collector",
          }
          def api(path, params=None):
              url = "https://api.github.com/" + path
              if params:
                  url += "?" + urllib.parse.urlencode(params)
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req) as r:
                  import json as _j
                  return _j.load(r)
          deadline = time.time() + 1200
          while True:
              runs = api(f"repos/{repo}/actions/runs", {"head_sha": sha, "per_page": 100}).get("workflow_runs", [])
              pending = False
              for t in targets:
                  st = [r["status"] for r in runs if r["name"] == t]
                  if any(s in ("queued", "in_progress", "requested", "waiting") for s in st):
                      pending = True
                      break
              if not pending or time.time() > deadline:
                  break
              time.sleep(15)
          PY
      - name: Download and unpack logs
        run: |
          python3 - <<'PY'
          import os, json, urllib.request, urllib.parse, zipfile, shutil
          repo = os.environ["OWNER_REPO"]
          sha = os.environ["HEAD_SHA"]
          targets = json.loads(os.environ["TARGETS"])
          headers = {
              "Authorization": f"Bearer {os.environ['GH_TOKEN']}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "gha-log-collector",
          }
          def api_json(path, params=None):
              url = "https://api.github.com/" + path
              if params:
                  url += "?" + urllib.parse.urlencode(params)
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req) as r:
                  import json as _j
                  return _j.load(r)

          def api_bytes(path):
              url = "https://api.github.com/" + path
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req) as r:
                  return r.read()

          runs = api_json(
              f"repos/{repo}/actions/runs",
              {"head_sha": sha, "per_page": 100},
          ).get("workflow_runs", [])
          tmp = "ci-logs/_tmp"
          shutil.rmtree("ci-logs/latest", ignore_errors=True)
          shutil.rmtree(tmp, ignore_errors=True)
          os.makedirs(tmp, exist_ok=True)
          for t in targets:
              cand = [
                  r
                  for r in runs
                  if r["name"] == t
                  and r["conclusion"]
                  in (
                      "success",
                      "failure",
                      "cancelled",
                      "timed_out",
                      "action_required",
                      "neutral",
                      "skipped",
                  )
              ]
              if not cand:
                  continue
              cand.sort(key=lambda r: r["run_number"], reverse=True)
              rid = cand[0]["id"]
              zbytes = api_bytes(f"repos/{repo}/actions/runs/{rid}/logs")
              zpath = os.path.join(tmp, f"{t}-{rid}.zip")
              with open(zpath, "wb") as f:
                  f.write(zbytes)
              outdir = os.path.join(tmp, t)
              os.makedirs(outdir, exist_ok=True)
              with zipfile.ZipFile(zpath) as z:
                  z.extractall(outdir)
              os.remove(zpath)
          shutil.move(tmp, "ci-logs/latest")
          PY
      - name: Commit and push
        env:
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
        run: |
          git add ci-logs
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "ci: persist all workflow logs for $HEAD_SHA [skip ci]"
            git pull --rebase -X ours origin "$HEAD_BRANCH"
            git push origin HEAD:$HEAD_BRANCH
          fi
