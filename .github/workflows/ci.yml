name: ci

on:
  pull_request:
    paths-ignore:
      - '.codex/**'
  push:
    branches: [ main ]   # exclude ci-logs
    paths-ignore:
      - '.codex/**'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  unit:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      - uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'npm'
          cache-dependency-path: |
            web/package-lock.json
            webapp/package-lock.json

      - name: Install Python dev deps
        shell: bash
        run: |
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi

      - name: Install service requirements
        shell: bash
        run: |
          for f in services/*/requirements.txt; do [ -f "$f" ] && pip install -r "$f" || true; done

      - name: Python unit tests
        shell: bash
        run: |
          if [ -f pyproject.toml ] || [ -f pytest.ini ]; then
            set -o pipefail
            pytest -q -m "not integration" 2>&1 | tee unit-pytest.log
            exit ${PIPESTATUS[0]}
          fi

      - name: Frontend web tests
        shell: bash
        run: |
          if [ -f web/package.json ]; then
            cd web
            set -o pipefail
            npm ci
            npm test 2>&1 | tee ../web-vitest.log
            exit ${PIPESTATUS[0]}
          fi

      - name: Frontend webapp build
        shell: bash
        run: |
          if [ -f webapp/package.json ]; then
            cd webapp
            set -o pipefail
            npm ci
            NODE_ENV=production npm run build 2>&1 | tee ../webapp-build.log
            exit ${PIPESTATUS[0]}
          fi

      - name: Upload artifacts (unit)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-${{ github.run_id }}-${{ github.run_attempt }}-unit
          path: |
            unit-pytest.log
            web-vitest.log
            webapp-build.log
          if-no-files-found: ignore
  integration:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: unit
    continue-on-error: true
    steps:
      - uses: actions/checkout@v5

      - name: Prepare .env.ci
        shell: bash
        run: |
          printf "PG_HOST=postgres\nPG_PORT=5432\nPG_USER=%s\nPG_PASSWORD=%s\nPG_DATABASE=%s\nPOSTGRES_HOST=postgres\nPOSTGRES_PORT=5432\nPOSTGRES_USER=%s\nPOSTGRES_PASSWORD=%s\nPOSTGRES_DB=%s\nDATABASE_URL=postgresql://%s:%s@postgres:5432/%s\n" "${{ secrets.PG_USER || 'postgres' }}" "${{ secrets.PG_PASSWORD || 'pass' }}" "${{ secrets.PG_DATABASE || 'awa' }}" "${{ secrets.PG_USER || 'postgres' }}" "${{ secrets.PG_PASSWORD || 'pass' }}" "${{ secrets.PG_DATABASE || 'awa' }}" "${{ secrets.PG_USER || 'postgres' }}" "${{ secrets.PG_PASSWORD || 'pass' }}" "${{ secrets.PG_DATABASE || 'awa' }}" > .env.ci

      - name: Build images
        shell: bash
        run: |
          export COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1
          COMPOSE_FILES=""
          [ -f docker-compose.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.yml"
          [ -f docker-compose.ci.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.ci.yml"
          [ -f docker-compose.postgres.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.postgres.yml"
          set -o pipefail
          docker compose $COMPOSE_FILES --env-file .env.ci build --pull 2>&1 | tee compose-build.txt
          exit ${PIPESTATUS[0]}

      - name: Up services
        shell: bash
        run: |
          COMPOSE_FILES=""
          [ -f docker-compose.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.yml"
          [ -f docker-compose.ci.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.ci.yml"
          [ -f docker-compose.postgres.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.postgres.yml"
          set -o pipefail
          docker compose $COMPOSE_FILES --env-file .env.ci up -d --wait 2>&1 | tee compose-up.txt
          exit ${PIPESTATUS[0]}

      - name: Dump compose logs
        if: always()
        shell: bash
        run: |
          COMPOSE_FILES=""
          [ -f docker-compose.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.yml"
          [ -f docker-compose.ci.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.ci.yml"
          [ -f docker-compose.postgres.yml ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.postgres.yml"
          docker compose $COMPOSE_FILES --env-file .env.ci ps > compose-ps.txt || true
          docker compose $COMPOSE_FILES --env-file .env.ci logs --no-color > compose-logs.txt || true

      - name: Python integration tests
        shell: bash
        run: |
          if [ -f pyproject.toml ] || [ -f pytest.ini ]; then
            set -o pipefail
            pytest -q -m integration 2>&1 | tee integration-pytest.log
            exit ${PIPESTATUS[0]}
          fi

      - name: Upload artifacts (integration)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-${{ github.run_id }}-${{ github.run_attempt }}-integration
          path: |
            compose-ps.txt
            compose-logs.txt
            compose-up.txt
            compose-build.txt
            integration-pytest.log
          if-no-files-found: ignore
  migrations:
    runs-on: ubuntu-latest
    needs: unit
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      - name: Install Python deps
        shell: bash
        run: |
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
      - name: Run migrations (dry run)
        shell: bash
        run: |
          echo "migrations placeholder" | tee migrations.log
      - name: Upload artifacts (migrations)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-${{ github.run_id }}-${{ github.run_attempt }}-migrations
          path: migrations.log
          if-no-files-found: ignore
  preview:
    runs-on: ubuntu-latest
    needs: unit
    steps:
      - uses: actions/checkout@v5
      - name: Build preview placeholder
        shell: bash
        run: |
          echo "https://example.com/preview" > preview-url.txt
      - name: Upload artifacts (preview)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-${{ github.run_id }}-${{ github.run_attempt }}-preview
          path: preview-url.txt
          if-no-files-found: ignore
  mirror_logs:
    needs: [unit, integration, migrations, preview]
    if: ${{ always() && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve PR number
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            let number = context.payload.pull_request?.number || null;
            if (!number) {
              const r = await github.rest.repos.listPullRequestsAssociatedWithCommit({owner, repo, commit_sha: context.sha});
              number = r.data?.[0]?.number || null;
            }
            if (!number) core.setFailed('No PR found for this run');
            core.setOutput('number', String(number));

      - name: Download all CI logs artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: ci-logs-*
          merge-multiple: true
          if-no-files-found: warn

      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Sanitize logs
        id: sanitize
        shell: bash
        run: |
          rm -rf logs_sanitized && mkdir -p logs_sanitized
          python - <<'PY'
          import os,re,glob
          os.makedirs("logs_sanitized", exist_ok=True)
          files = sorted(glob.glob("*.log")+glob.glob("*.txt"))
          rules = [
            (re.compile(r'(?i)\b(PG_PASSWORD|POSTGRES_PASSWORD|REDIS_PASSWORD|MINIO_SECRET_KEY|AWS_SECRET_ACCESS_KEY|OPENAI_API_KEY|API_KEY|SECRET|TOKEN|PASSWORD)\s*=\s*[^\s]+'), r'\1=<redacted>'),
            (re.compile(r'(?i)\bDATABASE_URL\s*=\s*\S+'), 'DATABASE_URL=<redacted>'),
            (re.compile(r'postgres(?:ql|\+psycopg)?://([^:@/]+):([^@/]+)@'), r'postgresql://\1:<redacted>@'),
            (re.compile(r'://([^:@/]+):([^@/]+)@'), r'://\1:<redacted>@'),
            (re.compile(r'Bearer\s+[A-Za-z0-9\-._~+/]+=*'), 'Bearer <redacted>'),
            (re.compile(r'(?i)(Authorization:\s*)\S+'), r'\1<redacted>')
          ]
          for src in files:
            try:
              t=open(src,'r',errors='ignore').read()
            except: continue
            for p,s in rules: t=p.sub(s,t)
            open(os.path.join("logs_sanitized", os.path.basename(src)),'w',encoding='utf-8').write(t)
          PY

      - name: Prepare sanitized mirror
        shell: bash
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git fetch origin ci-logs:ci-logs || echo "no remote ci-logs"
          git checkout ci-logs || git checkout -b ci-logs
          SHORT_SHA=$(git rev-parse --short $GITHUB_SHA)
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            BASE="mirror-logs/pr-${{ github.event.pull_request.number }}"
          else
            BASE="mirror-logs/branch-${{ github.ref_name }}"
          fi
          DEST="$BASE/sha-$SHORT_SHA"
          LATEST="$BASE/latest"
          rm -rf "$DEST" "$LATEST"
          mkdir -p "$DEST"
          cp -r ../logs_sanitized/. "$DEST/"
          ln -sfn "sha-$SHORT_SHA" "$LATEST" || cp -r "$DEST" "$LATEST"
          git add "$BASE"
          git commit -m "CI logs for $GITHUB_SHA" || echo "no changes"
          git push origin ci-logs

      - name: Resolve mirror path vars
        id: mirror_vars
        run: |
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            echo "path=mirror-logs/pr-${{ github.event.pull_request.number }}/latest" >> $GITHUB_OUTPUT
          else
            echo "path=mirror-logs/branch-${{ github.ref_name }}/latest" >> $GITHUB_OUTPUT
          fi

      - name: Gather logs for digest
        run: |
          mkdir -p digest_logs && cd digest_logs
          find ../artifacts -type f -name "*.tar.gz" -print0 | while IFS= read -r -d '' f; do
            tar -xzf "$f"
          done
          find ../artifacts -type f -maxdepth 2 -print0 | while IFS= read -r -d '' f; do
            cp -f "$f" . || true
          done
          test -f preview-url.txt || (find . -name "preview-url.txt" -print -quit -exec cp {} ./preview-url.txt \;)
          ls -la

      - name: Build PR comment digest (tails + errors)
        working-directory: digest_logs
        run: |
          chmod +x ../scripts/ci/make_pr_digest.sh
          MIRROR_PATH="${{ steps.mirror_vars.outputs.path }}" \
          ../scripts/ci/make_pr_digest.sh
          cp ci-digest.md ../ci-digest.md

      - name: Upsert PR comment with CI digest
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('ci-digest.md','utf8');
            const {owner, repo} = context.repo;
            const pr = context.payload.pull_request.number;
            const tag = '<!-- AWA-CI-DIGEST v2 -->';
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number: pr});
            const mine = comments.find(c => c.user.type === 'Bot' && c.body && c.body.includes(tag));
            if (mine) {
              await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number: pr, body});
            }

      - name: Append digest to Job Summary
        run: |
          cat ci-digest.md >> $GITHUB_STEP_SUMMARY
