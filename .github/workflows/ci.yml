---
name: CI

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:
    inputs:
      force_full_integration:
        description: Force the full integration + e2e suites
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  actions: read
  pull-requests: write

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

env:
  DOCKER_BUILDKIT: "1"
  COMPOSE_DOCKER_CLI_BUILD: "1"
  BASH_ENV: ${{ github.workspace }}/.github/bash_env

jobs:
  lint:
    name: lint
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: pip
          cache-dependency-path: |
            constraints.txt
            **/requirements*.txt

      - name: Upgrade pip tooling
        run: python -m pip install -U pip wheel

      - name: Install lint dependencies
        run: |
          python -m pip install -c constraints.txt -r requirements-dev.txt
          python -m pip install -c constraints.txt pre-commit ruff mypy
          python -m pip install -c constraints.txt -e packages/awa_common

      - name: Pre-commit (auto-fix, capture log)
        run: |
          mkdir -p artifacts
          set +e
          pre-commit run --all-files --show-diff-on-failure | tee artifacts/lint.log
          pc_status=${PIPESTATUS[0]}
          set -e
          if ! git diff --quiet; then
            git diff > artifacts/precommit.patch
            echo "::error::Pre-commit modified files. Apply artifacts/precommit.patch or run 'pre-commit run --all-files' locally and commit."
            exit 1
          fi
          if [ "${pc_status}" -ne 0 ]; then
            exit "${pc_status}"
          fi

      - name: Type check (mypy)
        run: |
          mypy --install-types --non-interactive . | tee -a artifacts/lint.log

      - name: Yamllint (workflows only)
        if: always()
        uses: ibiqlik/action-yamllint@v3
        env:
          LOGFILE: /tmp/yamllint.log
        with:
          file_or_dir: .github/workflows
          config_data: |
            extends: default
            rules:
              line-length: disable
              truthy: disable

      - name: actionlint (GitHub Actions syntax)
        if: always()
        uses: reviewdog/action-actionlint@v1
        with:
          github_token: ${{ github.token }}
          reporter: github-pr-check
          fail_level: error
          filter_mode: nofilter
          actionlint_flags: -color

      - name: Upload lint logs
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: logs-lint
          path: |
            artifacts/lint.log
            artifacts/precommit.patch
          if-no-files-found: ignore

  unit:
    name: unit
    needs: lint
    uses: ./.github/workflows/python-job.yml
    with:
      marker: unit
      python-version: '3.12'

  decide_integration_needed:
    name: decide_integration_needed
    needs: lint
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      run_integration: ${{ steps.decision.outputs.run_integration }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Determine integration requirement
        id: decision
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          FORCE_FULL_INPUT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.force_full_integration == 'true' && 'true' || 'false' }}
        run: |
          BASE_REF=""
          BASE_BRANCH_NAME="${DEFAULT_BRANCH}"
          LABEL_OVERRIDE="false"
          if [[ "${GITHUB_EVENT_NAME}" == "pull_request" ]]; then
            BASE_REF=$(jq -r '.pull_request.base.sha' "$GITHUB_EVENT_PATH")
            BASE_BRANCH_NAME=$(jq -r '.pull_request.base.ref' "$GITHUB_EVENT_PATH")
            LABEL_OVERRIDE=$(jq -r 'any(.pull_request.labels[]?.name; contains("run-integration")) // false' "$GITHUB_EVENT_PATH" || echo false)
          elif [[ "${GITHUB_EVENT_NAME}" == "push" ]]; then
            BASE_REF=$(jq -r '.before // empty' "$GITHUB_EVENT_PATH")
            if [[ "${BASE_REF}" == "0000000000000000000000000000000000000000" ]]; then
              BASE_REF=""
            fi
            BASE_BRANCH_NAME=$(jq -r '.ref // empty' "$GITHUB_EVENT_PATH" | sed 's#refs/heads/##') || true
            if [[ -z "${BASE_BRANCH_NAME}" ]]; then
              BASE_BRANCH_NAME="${DEFAULT_BRANCH}"
            fi
          else
            BASE_REF="origin/${DEFAULT_BRANCH}"
          fi
          FORCE_OVERRIDE="false"
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${FORCE_FULL_INPUT}" == "true" ]]; then
            FORCE_OVERRIDE="true"
          fi
          export DEFAULT_BRANCH
          export BASE_REF
          export BASE_BRANCH_NAME
          export FORCE_FULL_INTEGRATION="${FORCE_OVERRIDE}"
          export RUN_INTEGRATION_LABEL="${LABEL_OVERRIDE}"
          bash scripts/ci/should_run_integration.sh

  integration:
    name: integration
    needs:
      - lint
      - unit
      - decide_integration_needed
    if: ${{ always() && (needs.decide_integration_needed.outputs.run_integration == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.force_full_integration == 'true') || (github.event_name == 'pull_request' && contains(join(github.event.pull_request.labels.*.name, ' '), 'run-integration'))) }}
    uses: ./.github/workflows/python-job.yml
    with:
      marker: integration
      python-version: '3.12'
      database-url: postgresql+psycopg://postgres:postgres@localhost:5432/awa
      async-database-url: postgresql+asyncpg://postgres:postgres@localhost:5432/awa
      redis-url: redis://localhost:6379/0
      minio-endpoint: http://localhost:9000
      minio-access-key: minio
      minio-secret-key: miniosecret
      minio-bucket: awa-ci

  e2e:
    name: e2e-smoke
    needs:
      - integration
    if: ${{ needs.integration.result == 'success' }}
    uses: ./.github/workflows/python-job.yml
    with:
      marker: e2e
      python-version: '3.12'

  webapp-build:
    name: webapp-build
    runs-on: ubuntu-latest
    needs: unit
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Node
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: webapp/package-lock.json

      - name: Install dependencies
        working-directory: webapp
        run: npm ci

      - name: Build webapp
        working-directory: webapp
        env:
          NEXTAUTH_URL: http://localhost:3000
        run: npm run build

  secret-scan:
    name: secret-scan
    runs-on: ubuntu-24.04
    needs: lint
    timeout-minutes: 20
    permissions:
      contents: read
      pull-requests: read
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Gitleaks PR scan (baseline)
        if: ${{ github.event_name == 'pull_request' }}
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ github.token }}
        with:
          args: >
            detect --no-git --source . --config .gitleaks.toml
            --report-format json --report-path gitleaks-report.json
            --baseline-path .gitleaks-baseline.json --exit-code 1

  mirror-logs:
    name: mirror-logs
    runs-on: ubuntu-24.04
    needs:
      - lint
      - unit
      - decide_integration_needed
      - integration
      - e2e
      - secret-scan
      - webapp-build
    if: always()
    permissions:
      contents: read
      actions: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Detect PR comment capability
        id: cap
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.pull_request.head.repo.fork }}" = "false" ]; then
            echo "can_comment=true" >> "$GITHUB_OUTPUT"
          else
            echo "can_comment=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Collect artifact IDs
        id: artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const run_id = context.runId;
            const artifacts = await github.paginate(
              github.rest.actions.listWorkflowRunArtifacts,
              { owner, repo, run_id, per_page: 100 }
            );
            const formatIds = (filterFn) =>
              artifacts.filter(filterFn).map((a) => String(a.id)).join('\n');
            const findId = (name) =>
              artifacts.find((a) => a.name === name)?.id?.toString() ?? '';
            core.setOutput('log_ids', formatIds((a) => a.name.startsWith('logs-')));
            core.setOutput('coverage_ids', formatIds((a) => /coverage/i.test(a.name)));
            core.setOutput('gitleaks_ids', formatIds((a) => a.name.startsWith('gitleaks')));
            core.setOutput('diff_id', findId('diff-coverage'));
            core.setOutput('integration_id', findId('integration-test-artifacts'));

      - name: Download log artifacts
        if: steps.artifacts.outputs.log_ids != ''
        uses: actions/download-artifact@v4
        with:
          artifact-ids: ${{ steps.artifacts.outputs.log_ids }}
          path: artifacts
          merge-multiple: true

      - name: Download coverage artifacts
        if: steps.artifacts.outputs.coverage_ids != ''
        uses: actions/download-artifact@v4
        with:
          artifact-ids: ${{ steps.artifacts.outputs.coverage_ids }}
          path: artifacts
          merge-multiple: true

      - name: Download gitleaks artifacts
        if: steps.artifacts.outputs.gitleaks_ids != ''
        uses: actions/download-artifact@v4
        with:
          artifact-ids: ${{ steps.artifacts.outputs.gitleaks_ids }}
          path: artifacts
          merge-multiple: true

      - name: Download diff coverage artifact
        if: steps.artifacts.outputs.diff_id != ''
        uses: actions/download-artifact@v4
        with:
          artifact-ids: ${{ steps.artifacts.outputs.diff_id }}
          path: artifacts

      - name: Download integration junit artifacts
        if: steps.artifacts.outputs.integration_id != ''
        uses: actions/download-artifact@v4
        with:
          artifact-ids: ${{ steps.artifacts.outputs.integration_id }}
          path: artifacts

      - name: Prepare debug-bundle dirs
        if: always()
        run: mkdir -p debug-bundle/artifacts

      - name: Collect lint logs into debug-bundle
        if: always()
        run: |
          cp -f artifacts/lint.log debug-bundle/artifacts/lint.log 2>/dev/null || true

      - name: Fetch job URLs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const run_id = context.runId;
            const jobs = await github.paginate(
              github.rest.actions.listJobsForWorkflowRun,
              { owner, repo, run_id, per_page: 100 }
            );
            const out = jobs.map(job => ({
              name: job.name,
              url: job.html_url,
              status: job.conclusion || job.status,
              id: job.id,
            }));
            const fs = require('fs');
            fs.mkdirSync('artifacts', { recursive: true });
            fs.writeFileSync('artifacts/jobs.json', JSON.stringify(out, null, 2));

      - name: Build PR summary
        run: |
          python3 scripts/ci/make_pr_summary.py artifacts > artifacts/summary.md || echo "No summary" > artifacts/summary.md

      - name: Append summary to job summary
        run: cat artifacts/summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Update PR comment
        if: steps.cap.outputs.can_comment == 'true'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- MIRROR_LOGS_SUMMARY -->';
            const summary = fs.readFileSync('artifacts/summary.md','utf8');
            const body = `${marker}\n${summary}\n${marker}`;
            const {owner, repo} = context.repo;
            const pr = context.payload.pull_request.number;
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: pr, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr, body });
            }

      - uses: actions/upload-artifact@v5
        with:
          name: mirror-logs
          path: artifacts
          if-no-files-found: ignore
